type token =
  | TYPE
  | SEMICOLON
  | EQUALS
  | LSQBRACKET
  | RSQBRACKET
  | FUNCTION
  | RETURNS
  | LPAREN
  | RPAREN
  | COLON
  | COMMA
  | INT
  | REAL
  | BOOL
  | NODE
  | LET
  | TEL
  | MINUS
  | UMINUS
  | PLUS
  | MULT
  | DIV
  | INTDIV
  | MOD
  | TRUE
  | FALSE
  | NOT
  | AND
  | OR
  | XOR
  | IMPL
  | LT
  | GT
  | LTE
  | GTE
  | NEQ
  | IF
  | THEN
  | ELSE
  | WHEN
  | CURRENT
  | PRE
  | FBY
  | CONDACT
  | ARROW
  | PROPERTY
  | SUBRANGE
  | OF
  | ASSERT
  | METAPROPERTY of (string)
  | MAIN_NODE
  | VAR
  | CONST
  | DOT
  | TO_TOK
  | CONVERT_TO of (string)
  | CONVERT_FROM of (string)
  | NUM of (string)
  | FLOAT of (string)
  | SYM of (string)
  | EOF_TOK

open Parsing;;
let _ = parse_error;;
# 2 "kind1/lustre_parser.mly"
(*
This file is part of the Kind verifier

* Copyright (c) 2007-2012 by the Board of Trustees of the University of Iowa, 
* here after designated as the Copyright Holder.
* All rights reserved.
*
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions are met:
*     * Redistributions of source code must retain the above copyright
*       notice, this list of conditions and the following disclaimer.
*     * Redistributions in binary form must reproduce the above copyright
*       notice, this list of conditions and the following disclaimer in the
*       documentation and/or other materials provided with the distribution.
*     * Neither the name of the University of Iowa, nor the
*       names of its contributors may be used to endorse or promote products
*       derived from this software without specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER ''AS IS'' AND ANY
* EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
* DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE FOR ANY
* DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
* LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
* ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*)


  open Types
  open Exceptions
  open Lus_convert

  exception ForwardReference of string
  exception ParseMismatch


  let toss x = () (* toss outputs *)

  (* from (node,var) to varid *)
  let symidhash = (Hashtbl.create 100 : ((Types.node_id_t*string),int)Hashtbl.t)
  (* from varid to type *)
  let idtypehash = (Hashtbl.create 100 : (int,lustre_type)Hashtbl.t)
  (* from varid to varclass *)
  let idclasshash = (Hashtbl.create 100 : (int,varclass)Hashtbl.t)
  (* from id to the S_DEF *)
  let additional_constraints = (Hashtbl.create 1: (int,typed_stream)Hashtbl.t)
  (* from node name to id *)
  let nodeidhash = (Hashtbl.create 100: (string,int)Hashtbl.t)
  (* from sym to const *)
  let symconsthash = (Hashtbl.create 10: (string, Types.streamterm * Types.lustre_type)Hashtbl.t)
  (* from type name to type *)
  let typenamehash = (Hashtbl.create 100 : (string,lustre_type)Hashtbl.t)


  let idcounter = Lus_convert.idcounter

  (* set whenever we enter a new node definition *)
  let current_node = ref ""
  let current_node_id = ref 0
  let main_node = ref (None:int option)

  (* set whenever we enter a new classification scope *)
  let current_class = ref LOCAL
 
  (* List of properties *)
  let property_list = ref (S_TRUE,L_BOOL)
  let multi_property_list = ref []
  let nodes_property_list =   
    (Hashtbl.create 10: (node_id_t, typed_stream) Hashtbl.t) 
      
  (*List of assertions *)
  let assert_list = ref (S_TRUE,L_BOOL)
  let nodes_assert_list = 
    (Hashtbl.create 10: (node_id_t, typed_stream) Hashtbl.t) 
   
      
  let generate_eq (id, x_type) =
      (S_EQ ( ( (S_VAR ("ABC",id)), x_type), ((S_VAR("ABS",id)), x_type)) ) , L_BOOL
 


(*By Teme *)

(* This should return a list of default properties.*)
 let generate_default_property node_it = 
    let vars = 
      (Tables.get_node_inputs node_it) @ (Tables.get_node_outputs node_it)
    in
      List.fold_right
	(fun x y ->  ((S_AND ((generate_eq x), y)),L_BOOL ))
	vars
	(S_TRUE,L_BOOL)

    
  let cvcl_property = ref F_TRUE

  let safe_find = Tables.safe_find

  let var_def_gen () =
    Hashtbl.iter (fun (nid,var) id ->
		    let t = safe_find idtypehash id "var_def_gen" in
		    let c = safe_find idclasshash id "var_def_gen" in
		      Tables.update_varinfo id (nid,var,t,c)
		 ) symidhash ;;
  
  (* adding constants *)
  let add_const =
    Hashtbl.replace symconsthash

  let resolve_type x =
    try
      safe_find typenamehash x ("resolve_type:"^x) 
    with _ -> 
      let org_name = Tables.internal_name_to_original_name x in
      let line = !Lus_convert.linenum in
      let err_msg = "Type: '" ^ org_name ^ "' is not defined in line " ^ (string_of_int line) ^ "." in
    failwith err_msg
  let add_type x y =
    Hashtbl.replace typenamehash x y;;

  (* setting up some predefined type names *)

  add_type "int" L_INT;;
  add_type "real" L_REAL;;
  add_type "bool" L_BOOL;;  

  (* set up a true var for assertions *) 
  (* true is 1 *)
  (* false is 0 *)
  idcounter#set 100;; (* the first 100 "vars" are reserved for index vars *)

  let append_additional_constraints =
    Hashtbl.fold (fun i x y -> x::y) additional_constraints

  (* returns the triple node call name, line#, position#*)
  let node_pos target =
    (target,(!Lus_convert.linenum),
      Parsing.symbol_start()-(!Lus_convert.linepos))

# 210 "kind1/lustre_parser.ml"
let yytransl_const = [|
  257 (* TYPE *);
  258 (* SEMICOLON *);
  259 (* EQUALS *);
  260 (* LSQBRACKET *);
  261 (* RSQBRACKET *);
  262 (* FUNCTION *);
  263 (* RETURNS *);
  264 (* LPAREN *);
  265 (* RPAREN *);
  266 (* COLON *);
  267 (* COMMA *);
  268 (* INT *);
  269 (* REAL *);
  270 (* BOOL *);
  271 (* NODE *);
  272 (* LET *);
  273 (* TEL *);
  274 (* MINUS *);
  275 (* UMINUS *);
  276 (* PLUS *);
  277 (* MULT *);
  278 (* DIV *);
  279 (* INTDIV *);
  280 (* MOD *);
  281 (* TRUE *);
  282 (* FALSE *);
  283 (* NOT *);
  284 (* AND *);
  285 (* OR *);
  286 (* XOR *);
  287 (* IMPL *);
  288 (* LT *);
  289 (* GT *);
  290 (* LTE *);
  291 (* GTE *);
  292 (* NEQ *);
  293 (* IF *);
  294 (* THEN *);
  295 (* ELSE *);
  296 (* WHEN *);
  297 (* CURRENT *);
  298 (* PRE *);
  299 (* FBY *);
  300 (* CONDACT *);
  301 (* ARROW *);
  302 (* PROPERTY *);
  303 (* SUBRANGE *);
  304 (* OF *);
  305 (* ASSERT *);
  307 (* MAIN_NODE *);
  308 (* VAR *);
  309 (* CONST *);
  310 (* DOT *);
  311 (* TO_TOK *);
  317 (* EOF_TOK *);
    0|]

let yytransl_block = [|
  306 (* METAPROPERTY *);
  312 (* CONVERT_TO *);
  313 (* CONVERT_FROM *);
  314 (* NUM *);
  315 (* FLOAT *);
  316 (* SYM *);
    0|]

let yylhs = "\255\255\
\001\000\002\000\002\000\004\000\004\000\004\000\003\000\003\000\
\006\000\006\000\007\000\007\000\009\000\008\000\012\000\012\000\
\013\000\013\000\016\000\016\000\017\000\017\000\011\000\011\000\
\011\000\011\000\011\000\011\000\011\000\019\000\020\000\020\000\
\022\000\022\000\023\000\023\000\021\000\021\000\024\000\024\000\
\005\000\005\000\027\000\027\000\025\000\029\000\028\000\030\000\
\030\000\030\000\026\000\026\000\032\000\032\000\032\000\031\000\
\031\000\031\000\031\000\034\000\034\000\034\000\033\000\033\000\
\033\000\033\000\033\000\033\000\033\000\033\000\033\000\033\000\
\033\000\033\000\033\000\033\000\033\000\033\000\033\000\033\000\
\033\000\033\000\033\000\033\000\033\000\033\000\033\000\033\000\
\033\000\033\000\033\000\033\000\033\000\033\000\033\000\033\000\
\033\000\033\000\033\000\033\000\033\000\033\000\033\000\033\000\
\033\000\036\000\036\000\035\000\035\000\038\000\038\000\014\000\
\018\000\018\000\015\000\010\000\037\000\037\000\039\000\000\000"

let yylen = "\002\000\
\002\000\002\000\001\000\001\000\003\000\002\000\001\000\002\000\
\003\000\001\000\001\000\003\000\003\000\003\000\001\000\003\000\
\003\000\003\000\003\000\005\000\001\000\003\000\001\000\001\000\
\001\000\008\000\001\000\003\000\003\000\003\000\001\000\003\000\
\002\000\003\000\001\000\003\000\003\000\003\000\001\000\003\000\
\003\000\002\000\001\000\000\000\006\000\001\000\001\000\001\000\
\002\000\002\000\003\000\003\000\003\000\002\000\001\000\002\000\
\001\000\002\000\001\000\004\000\004\000\003\000\001\000\001\000\
\001\000\003\000\004\000\003\000\003\000\002\000\003\000\003\000\
\003\000\003\000\001\000\001\000\002\000\003\000\003\000\003\000\
\003\000\003\000\003\000\003\000\003\000\003\000\003\000\002\000\
\002\000\002\000\006\000\002\000\008\000\003\000\003\000\002\000\
\008\000\004\000\003\000\003\000\004\000\004\000\003\000\003\000\
\003\000\003\000\001\000\001\000\003\000\003\000\003\000\001\000\
\001\000\002\000\001\000\001\000\001\000\003\000\003\000\002\000"

let yydefred = "\000\000\
\000\000\000\000\000\000\000\000\000\000\120\000\000\000\000\000\
\003\000\000\000\000\000\010\000\000\000\116\000\000\000\011\000\
\000\000\047\000\000\000\000\000\000\000\015\000\001\000\002\000\
\000\000\006\000\008\000\000\000\000\000\000\000\042\000\000\000\
\000\000\000\000\000\000\000\000\000\000\005\000\000\000\000\000\
\000\000\000\000\000\000\055\000\000\000\000\000\000\000\000\000\
\000\000\108\000\000\000\000\000\031\000\000\000\041\000\012\000\
\000\000\025\000\023\000\024\000\000\000\027\000\013\000\033\000\
\000\000\000\000\046\000\000\000\112\000\115\000\017\000\018\000\
\016\000\000\000\000\000\000\000\052\000\000\000\000\000\000\000\
\000\000\000\000\000\000\075\000\076\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\064\000\065\000\
\000\000\000\000\054\000\000\000\000\000\051\000\058\000\056\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\034\000\000\000\109\000\049\000\050\000\
\000\000\000\000\000\000\000\000\117\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\053\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\062\000\000\000\000\000\110\000\000\000\037\000\032\000\
\038\000\040\000\000\000\000\000\028\000\029\000\000\000\113\000\
\000\000\036\000\043\000\045\000\000\000\103\000\000\000\099\000\
\000\000\105\000\104\000\000\000\000\000\000\000\000\000\000\000\
\066\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\100\000\060\000\061\000\
\000\000\022\000\114\000\000\000\000\000\000\000\000\000\118\000\
\000\000\000\000\000\000\101\000\102\000\067\000\098\000\000\000\
\000\000\000\000\000\000\000\000\000\000\020\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\026\000\093\000\097\000"

let yydgoto = "\002\000\
\006\000\007\000\008\000\009\000\010\000\011\000\015\000\012\000\
\016\000\094\000\111\000\021\000\022\000\095\000\096\000\112\000\
\113\000\177\000\030\000\052\000\065\000\035\000\066\000\054\000\
\013\000\031\000\180\000\019\000\068\000\077\000\046\000\047\000\
\122\000\048\000\049\000\123\000\124\000\050\000\125\000"

let yysindex = "\004\000\
\023\255\000\000\213\254\213\254\213\254\000\000\223\254\018\255\
\000\000\023\255\010\255\000\000\254\254\000\000\044\255\000\000\
\070\255\000\000\069\255\094\255\106\255\000\000\000\000\000\000\
\018\255\000\000\000\000\135\255\213\254\095\255\000\000\213\254\
\009\255\251\254\111\255\240\254\213\254\000\000\213\254\124\255\
\247\255\247\255\144\255\000\000\029\255\124\255\039\255\039\255\
\154\255\000\000\157\255\162\255\000\000\083\255\000\000\000\000\
\009\255\000\000\000\000\000\000\158\255\000\000\000\000\000\000\
\181\255\179\255\000\000\069\255\000\000\000\000\000\000\000\000\
\000\000\178\255\182\255\014\255\000\000\247\255\247\255\247\255\
\247\255\247\255\247\255\000\000\000\000\247\255\247\255\247\255\
\247\255\189\255\192\255\193\255\199\255\201\255\000\000\000\000\
\073\000\108\000\000\000\247\255\213\254\000\000\000\000\000\000\
\247\255\009\255\213\254\009\255\213\254\180\255\200\255\208\255\
\209\255\247\254\213\254\000\000\216\255\000\000\000\000\000\000\
\064\255\095\002\007\255\081\255\000\000\251\000\098\255\095\002\
\095\002\095\002\109\255\176\002\030\001\095\002\109\255\247\255\
\247\255\247\255\247\255\190\255\000\000\247\255\164\255\247\255\
\247\255\247\255\247\255\247\255\247\255\247\255\247\255\247\255\
\247\255\247\255\247\255\247\255\247\255\247\255\247\255\247\255\
\213\254\000\000\143\000\178\255\000\000\178\000\000\000\000\000\
\000\000\000\000\009\255\009\255\000\000\000\000\164\255\000\000\
\212\255\000\000\000\000\000\000\247\255\000\000\247\255\000\000\
\213\254\000\000\000\000\247\255\068\001\103\001\138\001\173\001\
\000\000\110\255\152\255\220\255\156\255\156\255\109\255\109\255\
\109\255\109\255\176\002\153\002\153\002\130\002\152\255\152\255\
\152\255\152\255\152\255\095\002\095\002\000\000\000\000\000\000\
\215\255\000\000\000\000\247\254\095\002\095\002\226\255\000\000\
\208\001\164\255\247\255\000\000\000\000\000\000\000\000\213\254\
\232\255\247\255\224\255\246\001\180\255\000\000\191\255\095\002\
\247\255\247\255\228\255\025\002\060\002\000\000\000\000\000\000"

let yyrindex = "\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\177\255\227\255\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\038\255\
\000\000\000\000\000\000\000\000\047\255\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\235\255\236\255\
\000\000\000\000\243\255\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\254\255\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\026\255\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\034\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\229\255\000\000\000\000\090\255\238\255\000\000\
\000\000\000\000\000\000\000\000\255\254\000\000\000\000\000\000\
\216\000\139\255\000\000\000\000\000\000\245\255\000\000\219\255\
\076\000\081\000\215\002\237\003\000\000\147\000\253\002\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\093\255\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\013\004\000\000\187\003\225\003\035\003\073\003\
\111\003\149\003\025\004\157\004\180\004\192\004\057\004\069\004\
\101\004\113\004\145\004\220\000\071\001\000\000\000\000\000\000\
\239\255\000\000\000\000\000\000\160\255\142\255\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\249\001\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"

let yygindex = "\000\000\
\000\000\000\000\129\000\027\000\000\000\000\000\000\000\000\000\
\209\000\253\255\230\255\000\000\225\000\223\255\228\000\035\000\
\094\000\048\000\000\000\000\000\233\255\201\000\155\000\000\000\
\000\000\241\000\000\000\000\000\000\000\229\000\107\000\000\000\
\234\255\000\000\000\000\187\255\000\000\225\255\091\000"

let yytablesize = 1517
let yytable = "\017\000\
\018\000\020\000\071\000\064\000\001\000\053\000\063\000\075\000\
\175\000\127\000\003\000\182\000\057\000\028\000\044\000\119\000\
\014\000\183\000\097\000\098\000\058\000\059\000\060\000\003\000\
\045\000\051\000\048\000\023\000\017\000\062\000\051\000\100\000\
\004\000\020\000\024\000\074\000\026\000\004\000\009\000\101\000\
\048\000\069\000\070\000\045\000\045\000\032\000\039\000\014\000\
\069\000\029\000\044\000\038\000\009\000\110\000\014\000\061\000\
\126\000\128\000\129\000\130\000\131\000\014\000\005\000\132\000\
\133\000\134\000\135\000\120\000\014\000\165\000\194\000\140\000\
\033\000\181\000\121\000\005\000\034\000\163\000\048\000\167\000\
\176\000\169\000\166\000\168\000\041\000\184\000\048\000\042\000\
\043\000\044\000\009\000\185\000\108\000\109\000\027\000\111\000\
\036\000\164\000\014\000\014\000\027\000\111\000\062\000\051\000\
\062\000\170\000\187\000\037\000\183\000\196\000\028\000\051\000\
\143\000\189\000\190\000\191\000\192\000\067\000\230\000\195\000\
\183\000\197\000\198\000\199\000\200\000\201\000\202\000\203\000\
\204\000\205\000\206\000\207\000\208\000\209\000\210\000\211\000\
\212\000\213\000\025\000\027\000\076\000\219\000\039\000\107\000\
\217\000\099\000\106\000\107\000\159\000\107\000\106\000\040\000\
\106\000\103\000\104\000\143\000\105\000\214\000\221\000\143\000\
\222\000\114\000\161\000\107\000\119\000\225\000\106\000\062\000\
\062\000\144\000\119\000\145\000\146\000\147\000\148\000\149\000\
\146\000\147\000\148\000\149\000\041\000\223\000\115\000\042\000\
\043\000\044\000\176\000\116\000\101\000\171\000\118\000\159\000\
\235\000\078\000\014\000\159\000\136\000\079\000\193\000\137\000\
\138\000\080\000\081\000\082\000\236\000\161\000\139\000\083\000\
\140\000\161\000\172\000\240\000\173\000\174\000\084\000\085\000\
\086\000\179\000\244\000\245\000\088\000\069\000\220\000\088\000\
\231\000\232\000\087\000\088\000\237\000\088\000\088\000\089\000\
\090\000\091\000\241\000\181\000\239\000\004\000\243\000\246\000\
\056\000\007\000\021\000\019\000\030\000\092\000\093\000\069\000\
\070\000\014\000\078\000\059\000\057\000\039\000\079\000\107\000\
\088\000\088\000\080\000\081\000\082\000\073\000\035\000\072\000\
\083\000\218\000\238\000\233\000\117\000\178\000\055\000\084\000\
\085\000\086\000\102\000\224\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\087\000\000\000\000\000\000\000\088\000\
\089\000\090\000\091\000\063\000\063\000\063\000\063\000\000\000\
\000\000\000\000\063\000\000\000\063\000\000\000\092\000\093\000\
\069\000\070\000\014\000\063\000\000\000\063\000\063\000\063\000\
\063\000\063\000\000\000\000\000\000\000\063\000\063\000\063\000\
\063\000\063\000\063\000\063\000\063\000\063\000\000\000\063\000\
\063\000\063\000\141\000\142\000\143\000\089\000\063\000\000\000\
\089\000\000\000\090\000\000\000\089\000\090\000\089\000\063\000\
\000\000\090\000\144\000\090\000\145\000\146\000\147\000\148\000\
\149\000\000\000\000\000\000\000\150\000\151\000\152\000\153\000\
\154\000\155\000\156\000\157\000\158\000\162\000\142\000\143\000\
\159\000\089\000\089\000\000\000\000\000\160\000\090\000\090\000\
\000\000\000\000\000\000\000\000\000\000\144\000\161\000\145\000\
\146\000\147\000\148\000\149\000\000\000\000\000\000\000\150\000\
\151\000\152\000\153\000\154\000\155\000\156\000\157\000\158\000\
\215\000\142\000\143\000\159\000\096\000\000\000\000\000\096\000\
\160\000\000\000\000\000\096\000\000\000\096\000\000\000\000\000\
\144\000\161\000\145\000\146\000\147\000\148\000\149\000\000\000\
\000\000\000\000\150\000\151\000\152\000\153\000\154\000\155\000\
\156\000\157\000\158\000\216\000\142\000\143\000\159\000\000\000\
\096\000\096\000\000\000\160\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\144\000\161\000\145\000\146\000\147\000\
\148\000\149\000\000\000\000\000\000\000\150\000\151\000\152\000\
\153\000\154\000\155\000\156\000\157\000\158\000\000\000\000\000\
\000\000\159\000\063\000\063\000\063\000\095\000\160\000\000\000\
\095\000\000\000\063\000\000\000\095\000\000\000\095\000\161\000\
\000\000\063\000\000\000\063\000\063\000\063\000\063\000\063\000\
\000\000\000\000\000\000\063\000\063\000\063\000\063\000\063\000\
\063\000\063\000\063\000\063\000\000\000\142\000\143\000\063\000\
\000\000\095\000\095\000\186\000\063\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\144\000\063\000\145\000\146\000\
\147\000\148\000\149\000\000\000\000\000\000\000\150\000\151\000\
\152\000\153\000\154\000\155\000\156\000\157\000\158\000\000\000\
\142\000\143\000\159\000\000\000\000\000\000\000\000\000\160\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\144\000\
\161\000\145\000\146\000\147\000\148\000\149\000\000\000\000\000\
\000\000\150\000\151\000\152\000\153\000\154\000\155\000\156\000\
\157\000\158\000\000\000\188\000\000\000\159\000\142\000\143\000\
\094\000\000\000\160\000\094\000\000\000\000\000\226\000\094\000\
\000\000\094\000\000\000\161\000\000\000\144\000\000\000\145\000\
\146\000\147\000\148\000\149\000\000\000\000\000\000\000\150\000\
\151\000\152\000\153\000\154\000\155\000\156\000\157\000\158\000\
\000\000\142\000\143\000\159\000\094\000\094\000\000\000\000\000\
\160\000\227\000\000\000\000\000\000\000\000\000\000\000\000\000\
\144\000\161\000\145\000\146\000\147\000\148\000\149\000\000\000\
\000\000\000\000\150\000\151\000\152\000\153\000\154\000\155\000\
\156\000\157\000\158\000\000\000\142\000\143\000\159\000\000\000\
\000\000\000\000\228\000\160\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\144\000\161\000\145\000\146\000\147\000\
\148\000\149\000\000\000\000\000\000\000\150\000\151\000\152\000\
\153\000\154\000\155\000\156\000\157\000\158\000\000\000\142\000\
\143\000\159\000\000\000\000\000\000\000\229\000\160\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\144\000\161\000\
\145\000\146\000\147\000\148\000\149\000\000\000\000\000\000\000\
\150\000\151\000\152\000\153\000\154\000\155\000\156\000\157\000\
\158\000\000\000\142\000\143\000\159\000\000\000\000\000\000\000\
\000\000\160\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\144\000\161\000\145\000\146\000\147\000\148\000\149\000\
\000\000\000\000\000\000\150\000\151\000\152\000\153\000\154\000\
\155\000\156\000\157\000\158\000\000\000\000\000\234\000\159\000\
\142\000\143\000\091\000\000\000\160\000\091\000\000\000\000\000\
\242\000\091\000\000\000\091\000\000\000\161\000\000\000\144\000\
\000\000\145\000\146\000\147\000\148\000\149\000\000\000\000\000\
\000\000\150\000\151\000\152\000\153\000\154\000\155\000\156\000\
\157\000\158\000\000\000\142\000\143\000\159\000\091\000\091\000\
\000\000\247\000\160\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\144\000\161\000\145\000\146\000\147\000\148\000\
\149\000\000\000\000\000\000\000\150\000\151\000\152\000\153\000\
\154\000\155\000\156\000\157\000\158\000\000\000\142\000\143\000\
\159\000\000\000\000\000\000\000\248\000\160\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\144\000\161\000\145\000\
\146\000\147\000\148\000\149\000\000\000\000\000\000\000\150\000\
\151\000\152\000\153\000\154\000\155\000\156\000\157\000\158\000\
\000\000\142\000\143\000\159\000\000\000\000\000\000\000\000\000\
\160\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\144\000\161\000\145\000\146\000\147\000\148\000\149\000\000\000\
\000\000\000\000\150\000\151\000\152\000\153\000\154\000\155\000\
\156\000\157\000\158\000\000\000\142\000\143\000\159\000\000\000\
\000\000\000\000\000\000\160\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\144\000\161\000\145\000\146\000\147\000\
\148\000\149\000\000\000\142\000\143\000\150\000\151\000\152\000\
\000\000\154\000\155\000\156\000\157\000\158\000\000\000\000\000\
\000\000\159\000\144\000\000\000\145\000\146\000\147\000\148\000\
\149\000\000\000\142\000\143\000\150\000\000\000\000\000\161\000\
\154\000\155\000\156\000\157\000\158\000\000\000\000\000\000\000\
\159\000\144\000\000\000\145\000\146\000\147\000\148\000\149\000\
\000\000\000\000\000\000\000\000\000\000\000\000\161\000\154\000\
\155\000\156\000\157\000\158\000\000\000\000\000\000\000\159\000\
\070\000\070\000\000\000\070\000\000\000\000\000\000\000\070\000\
\000\000\070\000\000\000\000\000\000\000\161\000\000\000\000\000\
\070\000\000\000\070\000\070\000\070\000\070\000\070\000\000\000\
\000\000\000\000\070\000\070\000\070\000\070\000\070\000\070\000\
\070\000\070\000\070\000\000\000\070\000\070\000\092\000\092\000\
\000\000\092\000\000\000\070\000\000\000\092\000\000\000\092\000\
\000\000\000\000\000\000\000\000\000\000\000\000\092\000\000\000\
\092\000\092\000\092\000\092\000\092\000\000\000\000\000\000\000\
\092\000\092\000\092\000\092\000\092\000\092\000\092\000\092\000\
\092\000\000\000\092\000\092\000\068\000\068\000\000\000\068\000\
\000\000\092\000\000\000\068\000\000\000\068\000\000\000\000\000\
\000\000\000\000\000\000\000\000\068\000\000\000\068\000\068\000\
\068\000\068\000\068\000\000\000\000\000\000\000\068\000\068\000\
\068\000\068\000\068\000\068\000\068\000\068\000\068\000\000\000\
\068\000\068\000\069\000\069\000\000\000\069\000\000\000\068\000\
\000\000\069\000\000\000\069\000\000\000\000\000\000\000\000\000\
\000\000\000\000\069\000\000\000\069\000\069\000\069\000\069\000\
\069\000\000\000\000\000\000\000\069\000\069\000\069\000\069\000\
\069\000\069\000\069\000\069\000\069\000\000\000\069\000\069\000\
\073\000\073\000\000\000\073\000\000\000\069\000\000\000\073\000\
\000\000\073\000\000\000\000\000\000\000\000\000\000\000\000\000\
\073\000\000\000\073\000\073\000\073\000\073\000\073\000\000\000\
\000\000\000\000\073\000\073\000\073\000\073\000\073\000\073\000\
\073\000\073\000\073\000\000\000\073\000\073\000\074\000\074\000\
\000\000\074\000\000\000\073\000\000\000\074\000\000\000\074\000\
\000\000\000\000\000\000\000\000\000\000\000\000\074\000\000\000\
\074\000\074\000\074\000\074\000\074\000\000\000\000\000\000\000\
\074\000\074\000\074\000\074\000\074\000\074\000\074\000\074\000\
\074\000\000\000\074\000\074\000\072\000\072\000\000\000\072\000\
\000\000\074\000\000\000\072\000\000\000\072\000\000\000\000\000\
\000\000\000\000\000\000\000\000\072\000\000\000\072\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\072\000\072\000\
\072\000\072\000\072\000\072\000\072\000\072\000\072\000\000\000\
\072\000\072\000\071\000\071\000\000\000\071\000\000\000\072\000\
\000\000\071\000\000\000\071\000\000\000\000\000\077\000\000\000\
\000\000\077\000\071\000\000\000\071\000\077\000\000\000\077\000\
\000\000\000\000\000\000\000\000\071\000\071\000\071\000\071\000\
\071\000\071\000\071\000\071\000\071\000\000\000\071\000\071\000\
\077\000\077\000\077\000\077\000\000\000\071\000\082\000\000\000\
\000\000\082\000\077\000\077\000\000\000\082\000\000\000\082\000\
\000\000\077\000\078\000\000\000\000\000\078\000\000\000\000\000\
\000\000\078\000\000\000\078\000\000\000\000\000\000\000\000\000\
\082\000\082\000\082\000\082\000\000\000\000\000\000\000\000\000\
\000\000\000\000\082\000\082\000\078\000\078\000\078\000\078\000\
\000\000\082\000\083\000\000\000\000\000\083\000\078\000\078\000\
\000\000\083\000\000\000\083\000\000\000\078\000\084\000\000\000\
\000\000\084\000\000\000\000\000\000\000\084\000\000\000\084\000\
\000\000\000\000\000\000\000\000\083\000\083\000\083\000\083\000\
\000\000\000\000\000\000\000\000\000\000\000\000\083\000\083\000\
\084\000\084\000\084\000\084\000\000\000\083\000\085\000\000\000\
\000\000\085\000\084\000\084\000\000\000\085\000\000\000\085\000\
\000\000\084\000\086\000\000\000\000\000\086\000\000\000\000\000\
\000\000\086\000\000\000\086\000\000\000\000\000\000\000\000\000\
\085\000\085\000\085\000\085\000\000\000\000\000\000\000\000\000\
\000\000\000\000\085\000\085\000\086\000\086\000\086\000\086\000\
\000\000\085\000\087\000\000\000\000\000\087\000\086\000\086\000\
\000\000\087\000\000\000\087\000\000\000\086\000\079\000\000\000\
\000\000\079\000\000\000\000\000\000\000\079\000\000\000\079\000\
\000\000\000\000\000\000\000\000\087\000\087\000\087\000\087\000\
\000\000\000\000\000\000\000\000\000\000\080\000\087\000\087\000\
\080\000\079\000\079\000\079\000\080\000\087\000\080\000\000\000\
\000\000\081\000\079\000\079\000\081\000\000\000\000\000\000\000\
\081\000\079\000\081\000\000\000\000\000\000\000\000\000\000\000\
\080\000\080\000\080\000\000\000\000\000\000\000\000\000\000\000\
\000\000\080\000\080\000\000\000\000\000\000\000\081\000\000\000\
\080\000\000\000\000\000\000\000\000\000\081\000\081\000\000\000\
\000\000\000\000\000\000\000\000\081\000"

let yycheck = "\003\000\
\004\000\005\000\036\000\009\001\001\000\029\000\033\000\039\000\
\018\001\079\000\001\001\005\001\004\001\016\001\016\001\002\001\
\060\001\011\001\041\000\042\000\012\001\013\001\014\001\001\001\
\028\000\029\000\001\001\061\001\032\000\033\000\034\000\003\001\
\015\001\037\000\008\000\039\000\010\000\015\001\001\001\011\001\
\015\001\058\001\059\001\047\000\048\000\002\001\008\001\001\001\
\058\001\052\001\052\001\025\000\015\001\057\000\060\001\047\001\
\079\000\080\000\081\000\082\000\083\000\015\001\053\001\086\000\
\087\000\088\000\089\000\054\001\060\001\101\000\140\000\008\001\
\003\001\010\001\078\000\053\001\008\001\100\000\053\001\106\000\
\114\000\108\000\105\000\107\000\046\001\005\001\061\001\049\001\
\050\001\051\001\053\001\011\001\010\001\011\001\005\001\003\001\
\003\001\101\000\060\001\053\001\011\001\009\001\106\000\107\000\
\108\000\109\000\009\001\002\001\011\001\143\000\016\001\115\000\
\004\001\136\000\137\000\138\000\139\000\007\001\009\001\142\000\
\011\001\144\000\145\000\146\000\147\000\148\000\149\000\150\000\
\151\000\152\000\153\000\154\000\155\000\156\000\157\000\158\000\
\159\000\160\000\010\000\011\000\017\001\175\000\008\001\005\001\
\171\000\002\001\005\001\009\001\040\001\011\001\009\001\017\001\
\011\001\047\000\048\000\004\001\003\001\161\000\181\000\004\001\
\183\000\004\001\054\001\002\001\005\001\188\000\010\001\171\000\
\172\000\018\001\011\001\020\001\021\001\022\001\023\001\024\001\
\021\001\022\001\023\001\024\001\046\001\185\000\002\001\049\001\
\050\001\051\001\220\000\009\001\011\001\010\001\009\001\040\001\
\226\000\004\001\060\001\040\001\008\001\008\001\009\001\008\001\
\008\001\012\001\013\001\014\001\227\000\054\001\008\001\018\001\
\008\001\054\001\011\001\234\000\005\001\005\001\025\001\026\001\
\027\001\002\001\241\000\242\000\002\001\058\001\011\001\005\001\
\005\001\011\001\037\001\009\001\232\000\011\001\041\001\042\001\
\043\001\044\001\011\001\010\001\005\001\061\001\048\001\012\001\
\032\000\015\001\005\001\005\001\016\001\056\001\057\001\058\001\
\059\001\060\001\004\001\017\001\017\001\011\001\008\001\011\001\
\038\001\039\001\012\001\013\001\014\001\037\000\009\001\036\000\
\018\001\172\000\232\000\220\000\068\000\115\000\030\000\025\001\
\026\001\027\001\046\000\185\000\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\037\001\255\255\255\255\255\255\041\001\
\042\001\043\001\044\001\002\001\003\001\004\001\005\001\255\255\
\255\255\255\255\009\001\255\255\011\001\255\255\056\001\057\001\
\058\001\059\001\060\001\018\001\255\255\020\001\021\001\022\001\
\023\001\024\001\255\255\255\255\255\255\028\001\029\001\030\001\
\031\001\032\001\033\001\034\001\035\001\036\001\255\255\038\001\
\039\001\040\001\002\001\003\001\004\001\002\001\045\001\255\255\
\005\001\255\255\002\001\255\255\009\001\005\001\011\001\054\001\
\255\255\009\001\018\001\011\001\020\001\021\001\022\001\023\001\
\024\001\255\255\255\255\255\255\028\001\029\001\030\001\031\001\
\032\001\033\001\034\001\035\001\036\001\002\001\003\001\004\001\
\040\001\038\001\039\001\255\255\255\255\045\001\038\001\039\001\
\255\255\255\255\255\255\255\255\255\255\018\001\054\001\020\001\
\021\001\022\001\023\001\024\001\255\255\255\255\255\255\028\001\
\029\001\030\001\031\001\032\001\033\001\034\001\035\001\036\001\
\002\001\003\001\004\001\040\001\002\001\255\255\255\255\005\001\
\045\001\255\255\255\255\009\001\255\255\011\001\255\255\255\255\
\018\001\054\001\020\001\021\001\022\001\023\001\024\001\255\255\
\255\255\255\255\028\001\029\001\030\001\031\001\032\001\033\001\
\034\001\035\001\036\001\002\001\003\001\004\001\040\001\255\255\
\038\001\039\001\255\255\045\001\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\018\001\054\001\020\001\021\001\022\001\
\023\001\024\001\255\255\255\255\255\255\028\001\029\001\030\001\
\031\001\032\001\033\001\034\001\035\001\036\001\255\255\255\255\
\255\255\040\001\003\001\004\001\005\001\002\001\045\001\255\255\
\005\001\255\255\011\001\255\255\009\001\255\255\011\001\054\001\
\255\255\018\001\255\255\020\001\021\001\022\001\023\001\024\001\
\255\255\255\255\255\255\028\001\029\001\030\001\031\001\032\001\
\033\001\034\001\035\001\036\001\255\255\003\001\004\001\040\001\
\255\255\038\001\039\001\009\001\045\001\255\255\255\255\255\255\
\255\255\255\255\255\255\255\255\018\001\054\001\020\001\021\001\
\022\001\023\001\024\001\255\255\255\255\255\255\028\001\029\001\
\030\001\031\001\032\001\033\001\034\001\035\001\036\001\255\255\
\003\001\004\001\040\001\255\255\255\255\255\255\255\255\045\001\
\255\255\255\255\255\255\255\255\255\255\255\255\255\255\018\001\
\054\001\020\001\021\001\022\001\023\001\024\001\255\255\255\255\
\255\255\028\001\029\001\030\001\031\001\032\001\033\001\034\001\
\035\001\036\001\255\255\038\001\255\255\040\001\003\001\004\001\
\002\001\255\255\045\001\005\001\255\255\255\255\011\001\009\001\
\255\255\011\001\255\255\054\001\255\255\018\001\255\255\020\001\
\021\001\022\001\023\001\024\001\255\255\255\255\255\255\028\001\
\029\001\030\001\031\001\032\001\033\001\034\001\035\001\036\001\
\255\255\003\001\004\001\040\001\038\001\039\001\255\255\255\255\
\045\001\011\001\255\255\255\255\255\255\255\255\255\255\255\255\
\018\001\054\001\020\001\021\001\022\001\023\001\024\001\255\255\
\255\255\255\255\028\001\029\001\030\001\031\001\032\001\033\001\
\034\001\035\001\036\001\255\255\003\001\004\001\040\001\255\255\
\255\255\255\255\009\001\045\001\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\018\001\054\001\020\001\021\001\022\001\
\023\001\024\001\255\255\255\255\255\255\028\001\029\001\030\001\
\031\001\032\001\033\001\034\001\035\001\036\001\255\255\003\001\
\004\001\040\001\255\255\255\255\255\255\009\001\045\001\255\255\
\255\255\255\255\255\255\255\255\255\255\255\255\018\001\054\001\
\020\001\021\001\022\001\023\001\024\001\255\255\255\255\255\255\
\028\001\029\001\030\001\031\001\032\001\033\001\034\001\035\001\
\036\001\255\255\003\001\004\001\040\001\255\255\255\255\255\255\
\255\255\045\001\255\255\255\255\255\255\255\255\255\255\255\255\
\255\255\018\001\054\001\020\001\021\001\022\001\023\001\024\001\
\255\255\255\255\255\255\028\001\029\001\030\001\031\001\032\001\
\033\001\034\001\035\001\036\001\255\255\255\255\039\001\040\001\
\003\001\004\001\002\001\255\255\045\001\005\001\255\255\255\255\
\011\001\009\001\255\255\011\001\255\255\054\001\255\255\018\001\
\255\255\020\001\021\001\022\001\023\001\024\001\255\255\255\255\
\255\255\028\001\029\001\030\001\031\001\032\001\033\001\034\001\
\035\001\036\001\255\255\003\001\004\001\040\001\038\001\039\001\
\255\255\009\001\045\001\255\255\255\255\255\255\255\255\255\255\
\255\255\255\255\018\001\054\001\020\001\021\001\022\001\023\001\
\024\001\255\255\255\255\255\255\028\001\029\001\030\001\031\001\
\032\001\033\001\034\001\035\001\036\001\255\255\003\001\004\001\
\040\001\255\255\255\255\255\255\009\001\045\001\255\255\255\255\
\255\255\255\255\255\255\255\255\255\255\018\001\054\001\020\001\
\021\001\022\001\023\001\024\001\255\255\255\255\255\255\028\001\
\029\001\030\001\031\001\032\001\033\001\034\001\035\001\036\001\
\255\255\003\001\004\001\040\001\255\255\255\255\255\255\255\255\
\045\001\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
\018\001\054\001\020\001\021\001\022\001\023\001\024\001\255\255\
\255\255\255\255\028\001\029\001\030\001\031\001\032\001\033\001\
\034\001\035\001\036\001\255\255\003\001\004\001\040\001\255\255\
\255\255\255\255\255\255\045\001\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\018\001\054\001\020\001\021\001\022\001\
\023\001\024\001\255\255\003\001\004\001\028\001\029\001\030\001\
\255\255\032\001\033\001\034\001\035\001\036\001\255\255\255\255\
\255\255\040\001\018\001\255\255\020\001\021\001\022\001\023\001\
\024\001\255\255\003\001\004\001\028\001\255\255\255\255\054\001\
\032\001\033\001\034\001\035\001\036\001\255\255\255\255\255\255\
\040\001\018\001\255\255\020\001\021\001\022\001\023\001\024\001\
\255\255\255\255\255\255\255\255\255\255\255\255\054\001\032\001\
\033\001\034\001\035\001\036\001\255\255\255\255\255\255\040\001\
\002\001\003\001\255\255\005\001\255\255\255\255\255\255\009\001\
\255\255\011\001\255\255\255\255\255\255\054\001\255\255\255\255\
\018\001\255\255\020\001\021\001\022\001\023\001\024\001\255\255\
\255\255\255\255\028\001\029\001\030\001\031\001\032\001\033\001\
\034\001\035\001\036\001\255\255\038\001\039\001\002\001\003\001\
\255\255\005\001\255\255\045\001\255\255\009\001\255\255\011\001\
\255\255\255\255\255\255\255\255\255\255\255\255\018\001\255\255\
\020\001\021\001\022\001\023\001\024\001\255\255\255\255\255\255\
\028\001\029\001\030\001\031\001\032\001\033\001\034\001\035\001\
\036\001\255\255\038\001\039\001\002\001\003\001\255\255\005\001\
\255\255\045\001\255\255\009\001\255\255\011\001\255\255\255\255\
\255\255\255\255\255\255\255\255\018\001\255\255\020\001\021\001\
\022\001\023\001\024\001\255\255\255\255\255\255\028\001\029\001\
\030\001\031\001\032\001\033\001\034\001\035\001\036\001\255\255\
\038\001\039\001\002\001\003\001\255\255\005\001\255\255\045\001\
\255\255\009\001\255\255\011\001\255\255\255\255\255\255\255\255\
\255\255\255\255\018\001\255\255\020\001\021\001\022\001\023\001\
\024\001\255\255\255\255\255\255\028\001\029\001\030\001\031\001\
\032\001\033\001\034\001\035\001\036\001\255\255\038\001\039\001\
\002\001\003\001\255\255\005\001\255\255\045\001\255\255\009\001\
\255\255\011\001\255\255\255\255\255\255\255\255\255\255\255\255\
\018\001\255\255\020\001\021\001\022\001\023\001\024\001\255\255\
\255\255\255\255\028\001\029\001\030\001\031\001\032\001\033\001\
\034\001\035\001\036\001\255\255\038\001\039\001\002\001\003\001\
\255\255\005\001\255\255\045\001\255\255\009\001\255\255\011\001\
\255\255\255\255\255\255\255\255\255\255\255\255\018\001\255\255\
\020\001\021\001\022\001\023\001\024\001\255\255\255\255\255\255\
\028\001\029\001\030\001\031\001\032\001\033\001\034\001\035\001\
\036\001\255\255\038\001\039\001\002\001\003\001\255\255\005\001\
\255\255\045\001\255\255\009\001\255\255\011\001\255\255\255\255\
\255\255\255\255\255\255\255\255\018\001\255\255\020\001\255\255\
\255\255\255\255\255\255\255\255\255\255\255\255\028\001\029\001\
\030\001\031\001\032\001\033\001\034\001\035\001\036\001\255\255\
\038\001\039\001\002\001\003\001\255\255\005\001\255\255\045\001\
\255\255\009\001\255\255\011\001\255\255\255\255\002\001\255\255\
\255\255\005\001\018\001\255\255\020\001\009\001\255\255\011\001\
\255\255\255\255\255\255\255\255\028\001\029\001\030\001\031\001\
\032\001\033\001\034\001\035\001\036\001\255\255\038\001\039\001\
\028\001\029\001\030\001\031\001\255\255\045\001\002\001\255\255\
\255\255\005\001\038\001\039\001\255\255\009\001\255\255\011\001\
\255\255\045\001\002\001\255\255\255\255\005\001\255\255\255\255\
\255\255\009\001\255\255\011\001\255\255\255\255\255\255\255\255\
\028\001\029\001\030\001\031\001\255\255\255\255\255\255\255\255\
\255\255\255\255\038\001\039\001\028\001\029\001\030\001\031\001\
\255\255\045\001\002\001\255\255\255\255\005\001\038\001\039\001\
\255\255\009\001\255\255\011\001\255\255\045\001\002\001\255\255\
\255\255\005\001\255\255\255\255\255\255\009\001\255\255\011\001\
\255\255\255\255\255\255\255\255\028\001\029\001\030\001\031\001\
\255\255\255\255\255\255\255\255\255\255\255\255\038\001\039\001\
\028\001\029\001\030\001\031\001\255\255\045\001\002\001\255\255\
\255\255\005\001\038\001\039\001\255\255\009\001\255\255\011\001\
\255\255\045\001\002\001\255\255\255\255\005\001\255\255\255\255\
\255\255\009\001\255\255\011\001\255\255\255\255\255\255\255\255\
\028\001\029\001\030\001\031\001\255\255\255\255\255\255\255\255\
\255\255\255\255\038\001\039\001\028\001\029\001\030\001\031\001\
\255\255\045\001\002\001\255\255\255\255\005\001\038\001\039\001\
\255\255\009\001\255\255\011\001\255\255\045\001\002\001\255\255\
\255\255\005\001\255\255\255\255\255\255\009\001\255\255\011\001\
\255\255\255\255\255\255\255\255\028\001\029\001\030\001\031\001\
\255\255\255\255\255\255\255\255\255\255\002\001\038\001\039\001\
\005\001\029\001\030\001\031\001\009\001\045\001\011\001\255\255\
\255\255\002\001\038\001\039\001\005\001\255\255\255\255\255\255\
\009\001\045\001\011\001\255\255\255\255\255\255\255\255\255\255\
\029\001\030\001\031\001\255\255\255\255\255\255\255\255\255\255\
\255\255\038\001\039\001\255\255\255\255\255\255\031\001\255\255\
\045\001\255\255\255\255\255\255\255\255\038\001\039\001\255\255\
\255\255\255\255\255\255\255\255\045\001"

let yynames_const = "\
  TYPE\000\
  SEMICOLON\000\
  EQUALS\000\
  LSQBRACKET\000\
  RSQBRACKET\000\
  FUNCTION\000\
  RETURNS\000\
  LPAREN\000\
  RPAREN\000\
  COLON\000\
  COMMA\000\
  INT\000\
  REAL\000\
  BOOL\000\
  NODE\000\
  LET\000\
  TEL\000\
  MINUS\000\
  UMINUS\000\
  PLUS\000\
  MULT\000\
  DIV\000\
  INTDIV\000\
  MOD\000\
  TRUE\000\
  FALSE\000\
  NOT\000\
  AND\000\
  OR\000\
  XOR\000\
  IMPL\000\
  LT\000\
  GT\000\
  LTE\000\
  GTE\000\
  NEQ\000\
  IF\000\
  THEN\000\
  ELSE\000\
  WHEN\000\
  CURRENT\000\
  PRE\000\
  FBY\000\
  CONDACT\000\
  ARROW\000\
  PROPERTY\000\
  SUBRANGE\000\
  OF\000\
  ASSERT\000\
  MAIN_NODE\000\
  VAR\000\
  CONST\000\
  DOT\000\
  TO_TOK\000\
  EOF_TOK\000\
  "

let yynames_block = "\
  METAPROPERTY\000\
  CONVERT_TO\000\
  CONVERT_FROM\000\
  NUM\000\
  FLOAT\000\
  SYM\000\
  "

let yyact = [|
  (fun _ -> failwith "parser")
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 1 : 'lustre_main) in
    Obj.repr(
# 224 "kind1/lustre_parser.mly"
  ( 
    let top_node = 
      if  "" = !OldFlags.user_specified_main_node_name 
      then 
	match !main_node with
	    Some n -> n
	  | None -> !current_node_id
      else 
	let main_node_name = !OldFlags.user_specified_main_node_name in 
	  try Hashtbl.find nodeidhash 
	    (Tables.LongStringHash.find Tables.sym_truenaming_table main_node_name) 
	  with Not_found -> 
	    let default_node_id =
 	      match !main_node with
		  Some n -> n
		| None -> !current_node_id
	    in
	    let default_node_name = 
	      (Tables.nodeid_to_original_name default_node_id) ^":"^
	      (Tables.get_nodename default_node_id) in 
	    let warning_msg = (
	      "Warning: Cannot the specified node: " ^ 
		main_node_name ^ ". \nUse default node " ^ default_node_name
	      ^ "\n" )
	    in
	      print_string warning_msg;
	      default_node_id
    in


    let default_property_list = 
	try Hashtbl.find nodes_property_list top_node 
	with Not_found -> 
	  failwith "NO PROPERTY SPECIFIED."
	  (* let node_name = (Tables.nodeid_to_original_name top_node  ) 
	    ^ " :" ^ (Tables.get_nodename top_node) 
	  in
	  let warning_msg = ("Warning: No property found in specified node: " ^ "\n"
				^ " KIND will assume :" ^ (node_name) ^ " as a default property.\n") in
	    print_string warning_msg;
	    generate_default_property top_node
	  *)
    in
      property_list := default_property_list;
      var_def_gen();
      (!cvcl_property, !property_list, !multi_property_list, top_node)
  )
# 930 "kind1/lustre_parser.ml"
               : Types.il_formula * Types.typed_stream * Types.typed_stream list * Types.node_id_t))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 1 : 'type_blocks) in
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'node_blocks) in
    Obj.repr(
# 275 "kind1/lustre_parser.mly"
  (  )
# 938 "kind1/lustre_parser.ml"
               : 'lustre_main))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'node_blocks) in
    Obj.repr(
# 277 "kind1/lustre_parser.mly"
  (  )
# 945 "kind1/lustre_parser.ml"
               : 'lustre_main))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'node_decl) in
    Obj.repr(
# 281 "kind1/lustre_parser.mly"
  ( )
# 952 "kind1/lustre_parser.ml"
               : 'node_blocks))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'node_decl) in
    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'type_blocks) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'node_blocks) in
    Obj.repr(
# 283 "kind1/lustre_parser.mly"
  ( )
# 961 "kind1/lustre_parser.ml"
               : 'node_blocks))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 1 : 'node_decl) in
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'node_blocks) in
    Obj.repr(
# 285 "kind1/lustre_parser.mly"
  ( )
# 969 "kind1/lustre_parser.ml"
               : 'node_blocks))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'type_block) in
    Obj.repr(
# 289 "kind1/lustre_parser.mly"
  ()
# 976 "kind1/lustre_parser.ml"
               : 'type_blocks))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 1 : 'type_block) in
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'type_blocks) in
    Obj.repr(
# 291 "kind1/lustre_parser.mly"
  ()
# 984 "kind1/lustre_parser.ml"
               : 'type_blocks))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'type_decls) in
    Obj.repr(
# 295 "kind1/lustre_parser.mly"
  ( (* return nothing *) )
# 991 "kind1/lustre_parser.ml"
               : 'type_block))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'const_block) in
    Obj.repr(
# 297 "kind1/lustre_parser.mly"
  ()
# 998 "kind1/lustre_parser.ml"
               : 'type_block))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'type_decl) in
    Obj.repr(
# 301 "kind1/lustre_parser.mly"
  ( (* return nothing *))
# 1005 "kind1/lustre_parser.ml"
               : 'type_decls))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'type_decls) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'type_decl) in
    Obj.repr(
# 303 "kind1/lustre_parser.mly"
  ( (* return nothing*) )
# 1013 "kind1/lustre_parser.ml"
               : 'type_decls))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'sym_name) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'type_def) in
    Obj.repr(
# 307 "kind1/lustre_parser.mly"
  ( add_type _1 _3 )
# 1021 "kind1/lustre_parser.ml"
               : 'type_decl))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'const_decls) in
    Obj.repr(
# 311 "kind1/lustre_parser.mly"
  ()
# 1028 "kind1/lustre_parser.ml"
               : 'const_block))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'const_decl) in
    Obj.repr(
# 315 "kind1/lustre_parser.mly"
  ()
# 1035 "kind1/lustre_parser.ml"
               : 'const_decls))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'const_decls) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'const_decl) in
    Obj.repr(
# 317 "kind1/lustre_parser.mly"
  ()
# 1043 "kind1/lustre_parser.ml"
               : 'const_decls))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'sym_name) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'integer) in
    Obj.repr(
# 321 "kind1/lustre_parser.mly"
  ( add_const _1 (S_INT(_3),L_INT) )
# 1051 "kind1/lustre_parser.ml"
               : 'const_decl))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'sym_name) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'real) in
    Obj.repr(
# 323 "kind1/lustre_parser.mly"
  ( 
    let i,n,d = _3 in
    add_const _1 (S_REAL(i,n,d),L_REAL)
  )
# 1062 "kind1/lustre_parser.ml"
               : 'const_decl))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'sym_name) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'type_def) in
    Obj.repr(
# 330 "kind1/lustre_parser.mly"
  ( [(_1,_3)] )
# 1070 "kind1/lustre_parser.ml"
               : 'rec_fields))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 4 : 'sym_name) in
    let _3 = (Parsing.peek_val __caml_parser_env 2 : 'type_def) in
    let _5 = (Parsing.peek_val __caml_parser_env 0 : 'rec_fields) in
    Obj.repr(
# 332 "kind1/lustre_parser.mly"
  ( (_1,_3) :: _5 )
# 1079 "kind1/lustre_parser.ml"
               : 'rec_fields))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'type_def) in
    Obj.repr(
# 336 "kind1/lustre_parser.mly"
  ( [_1] )
# 1086 "kind1/lustre_parser.ml"
               : 'tuple_fields))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'type_def) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'tuple_fields) in
    Obj.repr(
# 338 "kind1/lustre_parser.mly"
  ( _1 :: _3 )
# 1094 "kind1/lustre_parser.ml"
               : 'tuple_fields))
; (fun __caml_parser_env ->
    Obj.repr(
# 342 "kind1/lustre_parser.mly"
  ( L_REAL )
# 1100 "kind1/lustre_parser.ml"
               : 'type_def))
; (fun __caml_parser_env ->
    Obj.repr(
# 344 "kind1/lustre_parser.mly"
  ( L_BOOL )
# 1106 "kind1/lustre_parser.ml"
               : 'type_def))
; (fun __caml_parser_env ->
    Obj.repr(
# 346 "kind1/lustre_parser.mly"
  ( L_INT )
# 1112 "kind1/lustre_parser.ml"
               : 'type_def))
; (fun __caml_parser_env ->
    let _3 = (Parsing.peek_val __caml_parser_env 5 : 'signed_integer) in
    let _5 = (Parsing.peek_val __caml_parser_env 3 : 'signed_integer) in
    Obj.repr(
# 348 "kind1/lustre_parser.mly"
  (
    Globals.is_inter := true;
    L_INT_RANGE(_3,_5)
    ;
(*   L_INT*)
  )
# 1125 "kind1/lustre_parser.ml"
               : 'type_def))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'sym_name) in
    Obj.repr(
# 355 "kind1/lustre_parser.mly"
  (

    resolve_type _1

  )
# 1136 "kind1/lustre_parser.ml"
               : 'type_def))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'rec_fields) in
    Obj.repr(
# 361 "kind1/lustre_parser.mly"
  (
    let rt = List.sort (compare) _2 in
    L_RECORD rt
  )
# 1146 "kind1/lustre_parser.ml"
               : 'type_def))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'tuple_fields) in
    Obj.repr(
# 366 "kind1/lustre_parser.mly"
  (
    L_TUPLE _2
  )
# 1155 "kind1/lustre_parser.ml"
               : 'type_def))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'varlist) in
    Obj.repr(
# 372 "kind1/lustre_parser.mly"
  (
    Tables.add_node_locals !current_node_id _2;
  )
# 1164 "kind1/lustre_parser.ml"
               : 'var_block))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'param) in
    Obj.repr(
# 378 "kind1/lustre_parser.mly"
  (
    _1
  )
# 1173 "kind1/lustre_parser.ml"
               : 'varlist))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'varlist) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'param) in
    Obj.repr(
# 382 "kind1/lustre_parser.mly"
  ( _1 @ _3 )
# 1181 "kind1/lustre_parser.ml"
               : 'varlist))
; (fun __caml_parser_env ->
    Obj.repr(
# 386 "kind1/lustre_parser.mly"
  ( [] )
# 1187 "kind1/lustre_parser.ml"
               : 'param_list))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'params) in
    Obj.repr(
# 388 "kind1/lustre_parser.mly"
  ( 
    _2 
  )
# 1196 "kind1/lustre_parser.ml"
               : 'param_list))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'param) in
    Obj.repr(
# 394 "kind1/lustre_parser.mly"
  ( 
    _1 
  )
# 1205 "kind1/lustre_parser.ml"
               : 'params))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'param) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'params) in
    Obj.repr(
# 398 "kind1/lustre_parser.mly"
  ( 
    _1 @ _3
  )
# 1215 "kind1/lustre_parser.ml"
               : 'params))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'sym_name) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'type_def) in
    Obj.repr(
# 404 "kind1/lustre_parser.mly"
  ( let next_id = idcounter#next in
    Hashtbl.replace symidhash (!current_node_id,_1) next_id;
    Hashtbl.replace idtypehash next_id _3;
    (* current_class set previously in parse *)
    Hashtbl.replace idclasshash next_id !current_class;
    [(next_id,_3)]
  )
# 1229 "kind1/lustre_parser.ml"
               : 'param))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'sym_list) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'type_def) in
    Obj.repr(
# 412 "kind1/lustre_parser.mly"
  (
    List.map (fun x ->
      let next_id = idcounter#next in
      Hashtbl.replace symidhash (!current_node_id,x) next_id;
      Hashtbl.replace idtypehash next_id _3;
      (* current_class set previously in parse *)
      Hashtbl.replace idclasshash next_id !current_class;
      (next_id,_3)
    ) (List.rev _1)
  )
# 1246 "kind1/lustre_parser.ml"
               : 'param))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'sym_name) in
    Obj.repr(
# 425 "kind1/lustre_parser.mly"
  ( [_1] )
# 1253 "kind1/lustre_parser.ml"
               : 'sym_list))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'sym_list) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'sym_name) in
    Obj.repr(
# 427 "kind1/lustre_parser.mly"
  ( _3::_1 )
# 1261 "kind1/lustre_parser.ml"
               : 'sym_list))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'node_header) in
    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'var_block) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'let_block) in
    Obj.repr(
# 431 "kind1/lustre_parser.mly"
  ( 
    Tables.add_node_defs _1 _3
  )
# 1272 "kind1/lustre_parser.ml"
               : 'node_decl))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 1 : 'node_header) in
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'let_block) in
    Obj.repr(
# 435 "kind1/lustre_parser.mly"
  ( 
    Tables.add_node_defs _1 _2
  )
# 1282 "kind1/lustre_parser.ml"
               : 'node_decl))
; (fun __caml_parser_env ->
    Obj.repr(
# 440 "kind1/lustre_parser.mly"
            ( [] )
# 1288 "kind1/lustre_parser.ml"
               : 'semicolon_or_not))
; (fun __caml_parser_env ->
    Obj.repr(
# 441 "kind1/lustre_parser.mly"
    ( [] )
# 1294 "kind1/lustre_parser.ml"
               : 'semicolon_or_not))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 4 : 'node_name) in
    let _3 = (Parsing.peek_val __caml_parser_env 3 : 'param_list) in
    let _4 = (Parsing.peek_val __caml_parser_env 2 : 'node_out) in
    let _5 = (Parsing.peek_val __caml_parser_env 1 : 'param_list) in
    let _6 = (Parsing.peek_val __caml_parser_env 0 : 'semicolon_or_not) in
    Obj.repr(
# 446 "kind1/lustre_parser.mly"
  (
    current_class := LOCAL;
    Tables.add_node_inputs _2 _3;
    Tables.add_node_outputs _2 _5;
    _2
  )
# 1310 "kind1/lustre_parser.ml"
               : 'node_header))
; (fun __caml_parser_env ->
    Obj.repr(
# 455 "kind1/lustre_parser.mly"
  ( 
    current_class := OUTPUT;
  )
# 1318 "kind1/lustre_parser.ml"
               : 'node_out))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'sym_name) in
    Obj.repr(
# 461 "kind1/lustre_parser.mly"
  (
   (* set the current_node to this node's name *)
   current_node := _1;
   let next_id = idcounter#next in
   Hashtbl.replace nodeidhash _1 next_id;
   Tables.add_nodename next_id _1;
   current_node_id := next_id;
   current_class := INPUT;
   next_id
  )
# 1334 "kind1/lustre_parser.ml"
               : 'node_name))
; (fun __caml_parser_env ->
    Obj.repr(
# 473 "kind1/lustre_parser.mly"
      ( [] )
# 1340 "kind1/lustre_parser.ml"
               : 'tel_and_punctuation))
; (fun __caml_parser_env ->
    Obj.repr(
# 474 "kind1/lustre_parser.mly"
                ( [] )
# 1346 "kind1/lustre_parser.ml"
               : 'tel_and_punctuation))
; (fun __caml_parser_env ->
    Obj.repr(
# 475 "kind1/lustre_parser.mly"
          ( [] )
# 1352 "kind1/lustre_parser.ml"
               : 'tel_and_punctuation))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'flow_decls) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'tel_and_punctuation) in
    Obj.repr(
# 490 "kind1/lustre_parser.mly"
  ( 
    let out = append_additional_constraints _2 in
    Hashtbl.clear additional_constraints;
    out
  )
# 1364 "kind1/lustre_parser.ml"
               : 'let_block))
; (fun __caml_parser_env ->
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'tel_and_punctuation) in
    Obj.repr(
# 496 "kind1/lustre_parser.mly"
  (
    []
  )
# 1373 "kind1/lustre_parser.ml"
               : 'let_block))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'expr) in
    Obj.repr(
# 502 "kind1/lustre_parser.mly"
  ( 
 (*   let stored_property = 
      try Hashtbl.find nodes_property_list !current_node_id 
      with Not_found -> (S_TRUE,L_BOOL) in
    let new_property = (S_AND ($2,stored_property),L_BOOL) in
      Hashtbl.replace nodes_property_list !current_node_id new_property;
      () 
 *) 
(* Teme *)
  
  let stored_property = 
      try Hashtbl.find nodes_property_list !current_node_id;
      with Not_found -> (S_TRUE,L_BOOL)  in
    Globals.prop_typed_stream := _2;
    let new_property =  (S_AND (_2,stored_property),L_BOOL)  in
      Hashtbl.replace nodes_property_list !current_node_id new_property;
     multi_property_list := (_2 :: !multi_property_list); 
    ()
   
    
)
# 1400 "kind1/lustre_parser.ml"
               : 'property))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 1 : string) in
    Obj.repr(
# 524 "kind1/lustre_parser.mly"
  (
    let regex = Str.regexp "_x" in
    let index = 
      try Str.search_forward regex _1 0
      with Not_found -> -1
    in
    if index >= 0 then OldFlags.set_use_x();
    cvcl_property := Lus_convert.f_and !cvcl_property (F_STR _1);
    ()
  )
# 1416 "kind1/lustre_parser.ml"
               : 'property))
; (fun __caml_parser_env ->
    Obj.repr(
# 535 "kind1/lustre_parser.mly"
  (
    main_node := Some !current_node_id
  )
# 1424 "kind1/lustre_parser.ml"
               : 'property))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 1 : 'flow_decl) in
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'flow_decls) in
    Obj.repr(
# 541 "kind1/lustre_parser.mly"
  ( 
    List.rev_append _1 _2
  )
# 1434 "kind1/lustre_parser.ml"
               : 'flow_decls))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'flow_decl) in
    Obj.repr(
# 545 "kind1/lustre_parser.mly"
  ( 
    _1
  )
# 1443 "kind1/lustre_parser.ml"
               : 'flow_decls))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 1 : 'property) in
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'flow_decls) in
    Obj.repr(
# 549 "kind1/lustre_parser.mly"
  ( 
    _2
  )
# 1453 "kind1/lustre_parser.ml"
               : 'flow_decls))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'property) in
    Obj.repr(
# 553 "kind1/lustre_parser.mly"
  ( 
    [] 
  )
# 1462 "kind1/lustre_parser.ml"
               : 'flow_decls))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 3 : 'sym_name) in
    let _3 = (Parsing.peek_val __caml_parser_env 1 : 'expr) in
    Obj.repr(
# 559 "kind1/lustre_parser.mly"
  (
   (* here we try to simplify the condact expressions *)
   (* returns S_DEF(-1,_,_) to indicate an ignorable equation *)
   try
    let id = Hashtbl.find symidhash (!current_node_id,_1) in
    let lhs = S_VAR((!current_node)^"_$1$_"^(_1),id),safe_find idtypehash id "flow_decl1" in
    let nid = !current_node_id in
    (* try to compress condact variables *)
    match _3 with
        S_VAR(sym,id),_ -> 
           begin
             try 
               let nid,x,y,z,t =
                  match Hashtbl.find additional_constraints id with
                    (S_DEF(nid,_,(S_CONDACT(x,y,z,_),t)),L_BOOL) -> nid,x,y,z,t
                   | _ -> raise ParseMismatch
               in
               Hashtbl.remove additional_constraints id;
               Hashtbl.remove symidhash (!current_node_id,sym);
               let cond = S_CONDACT(x,y,z,lhs),t in
               [S_DEF(nid,lhs,cond),L_BOOL]
             with Not_found ->
               [S_DEF(nid,lhs,_3),L_BOOL] 
           end
      | _ -> 
             [S_DEF(nid,lhs,_3),L_BOOL]
   with Not_found ->
     []
  )
# 1498 "kind1/lustre_parser.ml"
               : 'flow_decl))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 3 : 'symlist) in
    let _3 = (Parsing.peek_val __caml_parser_env 1 : 'expr) in
    Obj.repr(
# 589 "kind1/lustre_parser.mly"
  (
   try 
     let vlist = List.map (fun e ->
         let id = Hashtbl.find symidhash (!current_node_id,e) in
         S_VAR((!current_node)^"_$2$_"^e,id),safe_find idtypehash id "flow_decl2"
       ) _1 
     in
     let tlist = List.map (fun (_,t1) -> t1) vlist in
     let nid = !current_node_id in
     let lhs = S_TUPLELIT(vlist), L_TUPLE(tlist) in
     match _3 with
         S_VAR(sym,id),_ -> 
           begin
             try 
               let nid,x,y,z,t =
                  match Hashtbl.find additional_constraints id with
                    (S_DEF(nid,_,(S_CONDACT(x,y,z,_),t)),L_BOOL) -> nid,x,y,z,t
                   | _ -> raise ParseMismatch
               in
               Hashtbl.remove additional_constraints id;
               Hashtbl.remove symidhash (!current_node_id,sym);
               let cond = S_CONDACT(x,y,z,lhs),t in
               [S_DEF(nid,lhs,cond),L_BOOL]
             with Not_found ->
               [S_DEF(nid,lhs,_3),L_BOOL] 
           end
       | _ -> [S_DEF(nid,lhs,_3),L_BOOL]
   with Not_found -> []
  )
# 1534 "kind1/lustre_parser.ml"
               : 'flow_decl))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'expr) in
    Obj.repr(
# 619 "kind1/lustre_parser.mly"
  (
   (* here we assert that the expr is TRUE *)
    
     let nid = !current_node_id in
      [S_ASSERT(nid,_2),L_BOOL] 
   

    (*let assertion = 
      try Hashtbl.find nodes_assert_list !current_node_id 
      with Not_found -> (S_TRUE,L_BOOL) in
    let new_assertion = (S_AND ($2,assertion),L_BOOL) in
      Hashtbl.replace nodes_assert_list !current_node_id new_assertion
    *)
  )
# 1554 "kind1/lustre_parser.ml"
               : 'flow_decl))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'sym_name) in
    Obj.repr(
# 636 "kind1/lustre_parser.mly"
  (
    try
      (* replace var with const expression *)
      Hashtbl.find symconsthash _1
    with Not_found ->
begin 
    try
      let id = Hashtbl.find symidhash (!current_node_id,_1) in
        let t = match Hashtbl.find idtypehash id with
           L_INT_RANGE(_,_) -> L_INT
        | x -> x
      in
      S_VAR((!current_node)^"_$3$_"^(_1),id),t
    with Not_found ->
      Printf.printf "symbol %s not found in node %s\n" (Tables.resolve_var_name _1) (Tables.resolve_var_name !current_node);
      raise Not_found
end
  )
# 1578 "kind1/lustre_parser.ml"
               : 'expr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'integer) in
    Obj.repr(
# 655 "kind1/lustre_parser.mly"
  ( 
    S_INT(_1),L_INT 
  )
# 1587 "kind1/lustre_parser.ml"
               : 'expr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'real) in
    Obj.repr(
# 659 "kind1/lustre_parser.mly"
  ( 
    let i,n,d = _1 in
    S_REAL(i,n,d),L_REAL 
  )
# 1597 "kind1/lustre_parser.ml"
               : 'expr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'sym_name) in
    Obj.repr(
# 664 "kind1/lustre_parser.mly"
  (
    (* node or function call *)
    let nid = safe_find nodeidhash _1 ("expr:node "^_1) in
    let rtl = try
      List.map (fun (_,y) -> y) 
         (Tables.get_node_outputs nid)
      with Not_found ->
        raise (ForwardReference _1)
    in
    let rettype = match rtl with
          [x] -> x
        | x -> L_TUPLE(x)
    in
    toss(Lus_types.match_types_list [] (Tables.get_node_inputs nid));
    let (a,b,c) = node_pos nid in
    S_NODE(a,b,c,[]),rettype
  )
# 1620 "kind1/lustre_parser.ml"
               : 'expr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 3 : 'sym_name) in
    let _3 = (Parsing.peek_val __caml_parser_env 1 : 'exprlist) in
    Obj.repr(
# 682 "kind1/lustre_parser.mly"
  (
    (* node or function call *)
    let nid = safe_find nodeidhash _1 ("expr:node "^_1) in
    let elist = List.rev _3 in
    let rtl = try
      List.map (fun (_,y) -> y) 
         (Tables.get_node_outputs nid)
      with Not_found ->
        raise (ForwardReference _1)
    in
    let rettype = match rtl with
          [x] -> x
        | x -> L_TUPLE(x)
    in
    toss(Lus_types.match_types_list elist (Tables.get_node_inputs nid));
    let (a,b,c) = node_pos nid in
    S_NODE(a,b,c,elist),rettype
  )
# 1645 "kind1/lustre_parser.ml"
               : 'expr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'expr) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'expr) in
    Obj.repr(
# 701 "kind1/lustre_parser.mly"
  ( 
    S_MULT(_1,_3), Lus_types.match_types _1 _3
  )
# 1655 "kind1/lustre_parser.ml"
               : 'expr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'expr) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'expr) in
    Obj.repr(
# 705 "kind1/lustre_parser.mly"
  ( 
(*    S_DIV($1,$3), Lus_types.match_types $1 $3 Yeting. The type should be real*)
    S_DIV(_1,_3), (Lus_types.match_types _1 _3; L_REAL) 
  )
# 1666 "kind1/lustre_parser.ml"
               : 'expr))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'expr) in
    Obj.repr(
# 710 "kind1/lustre_parser.mly"
  ( 
    S_UMINUS(_2), Lus_types.match_type_is_numeric _2
  )
# 1675 "kind1/lustre_parser.ml"
               : 'expr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'expr) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'expr) in
    Obj.repr(
# 714 "kind1/lustre_parser.mly"
  ( 
    S_PLUS(_1,_3), Lus_types.match_types _1 _3
  )
# 1685 "kind1/lustre_parser.ml"
               : 'expr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'expr) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'expr) in
    Obj.repr(
# 718 "kind1/lustre_parser.mly"
  ( 
    S_MINUS(_1,_3), Lus_types.match_types _1 _3 
  )
# 1695 "kind1/lustre_parser.ml"
               : 'expr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'expr) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'expr) in
    Obj.repr(
# 722 "kind1/lustre_parser.mly"
  ( 
    S_INTDIV(_1,_3),Lus_types.match_types_int _1 _3
  )
# 1705 "kind1/lustre_parser.ml"
               : 'expr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'expr) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'expr) in
    Obj.repr(
# 726 "kind1/lustre_parser.mly"
  ( 
    S_MOD(_1,_3),Lus_types.match_types_int _1 _3
  )
# 1715 "kind1/lustre_parser.ml"
               : 'expr))
; (fun __caml_parser_env ->
    Obj.repr(
# 730 "kind1/lustre_parser.mly"
  ( S_TRUE,L_BOOL )
# 1721 "kind1/lustre_parser.ml"
               : 'expr))
; (fun __caml_parser_env ->
    Obj.repr(
# 732 "kind1/lustre_parser.mly"
  ( S_FALSE,L_BOOL )
# 1727 "kind1/lustre_parser.ml"
               : 'expr))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'expr) in
    Obj.repr(
# 734 "kind1/lustre_parser.mly"
  (
      S_NOT(_2), Lus_types.match_types_bool _2 (S_TRUE,L_BOOL)
  )
# 1736 "kind1/lustre_parser.ml"
               : 'expr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'expr) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'expr) in
    Obj.repr(
# 738 "kind1/lustre_parser.mly"
  (
      S_AND(_1,_3),Lus_types.match_types_bool _1 _3
  )
# 1746 "kind1/lustre_parser.ml"
               : 'expr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'expr) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'expr) in
    Obj.repr(
# 742 "kind1/lustre_parser.mly"
  ( 
      S_OR(_1,_3),Lus_types.match_types_bool _1 _3
  )
# 1756 "kind1/lustre_parser.ml"
               : 'expr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'expr) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'expr) in
    Obj.repr(
# 746 "kind1/lustre_parser.mly"
  ( 
      S_XOR(_1,_3),Lus_types.match_types_bool _1 _3
  )
# 1766 "kind1/lustre_parser.ml"
               : 'expr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'expr) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'expr) in
    Obj.repr(
# 750 "kind1/lustre_parser.mly"
  (
      S_IMPL(_1,_3),Lus_types.match_types_bool _1 _3
  )
# 1776 "kind1/lustre_parser.ml"
               : 'expr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'expr) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'expr) in
    Obj.repr(
# 754 "kind1/lustre_parser.mly"
  ( 
    toss(Lus_types.match_types _1 _3);
    S_EQ(_1,_3),L_BOOL
  )
# 1787 "kind1/lustre_parser.ml"
               : 'expr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'expr) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'expr) in
    Obj.repr(
# 759 "kind1/lustre_parser.mly"
  ( 
    S_LT(_1,_3),Lus_types.match_types_nrel _1 _3
  )
# 1797 "kind1/lustre_parser.ml"
               : 'expr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'expr) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'expr) in
    Obj.repr(
# 763 "kind1/lustre_parser.mly"
  ( 
    S_GT(_1,_3),Lus_types.match_types_nrel _1 _3
  )
# 1807 "kind1/lustre_parser.ml"
               : 'expr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'expr) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'expr) in
    Obj.repr(
# 767 "kind1/lustre_parser.mly"
  ( 
    S_LTE(_1,_3),Lus_types.match_types_nrel _1 _3
  )
# 1817 "kind1/lustre_parser.ml"
               : 'expr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'expr) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'expr) in
    Obj.repr(
# 771 "kind1/lustre_parser.mly"
  ( 
    S_GTE(_1,_3),Lus_types.match_types_nrel _1 _3
  )
# 1827 "kind1/lustre_parser.ml"
               : 'expr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'expr) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'expr) in
    Obj.repr(
# 775 "kind1/lustre_parser.mly"
  (
    S_NOT (S_EQ(_1,_3),Lus_types.match_types_nrel _1 _3), L_BOOL
  )
# 1837 "kind1/lustre_parser.ml"
               : 'expr))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'expr) in
    Obj.repr(
# 779 "kind1/lustre_parser.mly"
  ( 
    S_COERCE_TO_INT (_2),L_INT 
  )
# 1846 "kind1/lustre_parser.ml"
               : 'expr))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'expr) in
    Obj.repr(
# 783 "kind1/lustre_parser.mly"
  ( 
    S_COERCE_TO_REAL (_2),L_REAL 
  )
# 1855 "kind1/lustre_parser.ml"
               : 'expr))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'expr) in
    Obj.repr(
# 787 "kind1/lustre_parser.mly"
  (
    S_ITE((S_EQ(_2,(S_INT(0),L_INT)),L_BOOL),(S_FALSE,L_BOOL),(S_TRUE,L_BOOL)),L_BOOL
  )
# 1864 "kind1/lustre_parser.ml"
               : 'expr))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 4 : 'expr) in
    let _4 = (Parsing.peek_val __caml_parser_env 2 : 'expr) in
    let _6 = (Parsing.peek_val __caml_parser_env 0 : 'expr) in
    Obj.repr(
# 791 "kind1/lustre_parser.mly"
  ( 
      S_ITE(_2,_4,_6), Lus_types.match_types_ite _2 _4 _6
  )
# 1875 "kind1/lustre_parser.ml"
               : 'expr))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'expr) in
    Obj.repr(
# 795 "kind1/lustre_parser.mly"
  ( 
    S_PRE(_2), Lus_types.gettype _2
  )
# 1884 "kind1/lustre_parser.ml"
               : 'expr))
; (fun __caml_parser_env ->
    let _3 = (Parsing.peek_val __caml_parser_env 5 : 'expr) in
    let _5 = (Parsing.peek_val __caml_parser_env 3 : 'integer) in
    let _7 = (Parsing.peek_val __caml_parser_env 1 : 'expr) in
    Obj.repr(
# 799 "kind1/lustre_parser.mly"
  (
    S_FBY(_3,_5,_7), Lus_types.gettype _3
  )
# 1895 "kind1/lustre_parser.ml"
               : 'expr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'expr) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'expr) in
    Obj.repr(
# 803 "kind1/lustre_parser.mly"
  ( 
    S_FOLLOWEDBY(_1,_3), Lus_types.match_types _1 _3
  )
# 1905 "kind1/lustre_parser.ml"
               : 'expr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'expr) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'expr) in
    Obj.repr(
# 807 "kind1/lustre_parser.mly"
  (
    S_WHEN(_1,_3), Lus_types.match_types_ite _3 _1 _1
  )
# 1915 "kind1/lustre_parser.ml"
               : 'expr))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'expr) in
    Obj.repr(
# 811 "kind1/lustre_parser.mly"
  (
    S_CURRENT(_2), Lus_types.gettype _2
  )
# 1924 "kind1/lustre_parser.ml"
               : 'expr))
; (fun __caml_parser_env ->
    let _3 = (Parsing.peek_val __caml_parser_env 5 : 'expr) in
    let _5 = (Parsing.peek_val __caml_parser_env 3 : 'expr) in
    let _7 = (Parsing.peek_val __caml_parser_env 1 : 'expr) in
    Obj.repr(
# 815 "kind1/lustre_parser.mly"
  (
    (* this is actually a SCADE macro *)
    (* clock,expr,defaults *)
    (* we generate a fresh variable for this, and may then compress it later
       in the parsing *)
    let next_id = idcounter#next in
    let name = "_tmp_"^(string_of_int next_id) in
    let t = Lus_types.gettype _5 in
    Hashtbl.replace symidhash (!current_node_id,name) next_id;
    Hashtbl.replace idtypehash next_id t;
    Hashtbl.replace idclasshash next_id LOCAL;
    let e = S_VAR((*(!current_node)^"_"^*)name,next_id),t in
    let cond = S_CONDACT(_3,_5,_7,e),t in
    let nid = !current_node_id in
    Hashtbl.replace additional_constraints next_id 
        (S_DEF(nid,e,cond),L_BOOL);
    e
  )
# 1950 "kind1/lustre_parser.ml"
               : 'expr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 3 : 'expr) in
    let _3 = (Parsing.peek_val __caml_parser_env 1 : 'integer) in
    Obj.repr(
# 834 "kind1/lustre_parser.mly"
  (
    (* tuple deref placeholder *)
    S_TUPLEREF(_1,_3),(Lus_types.is_tuple_type _1 _3)
  )
# 1961 "kind1/lustre_parser.ml"
               : 'expr))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'record_literal_fields) in
    Obj.repr(
# 839 "kind1/lustre_parser.mly"
  (
    let r = List.sort (compare) _2 in
    let t1 = List.map (fun (f,(_,t)) -> (f,t)) r in
    let t2 = List.sort (compare) t1 in
    S_RECORDLIT(r),L_RECORD(t2)
  )
# 1973 "kind1/lustre_parser.ml"
               : 'expr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'expr) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'sym_name) in
    Obj.repr(
# 846 "kind1/lustre_parser.mly"
  (
    (* record deref placeholder *)
    let t1 = match _1 with
      (_,L_RECORD t1) -> t1
      | _ -> raise ParseMismatch
    in
    let rec getftype fl = 
      match fl with
        (fn,ft)::x -> if fn = _3 then ft else getftype x
       | [] -> raise (IdNotFound "getftype")
    in
    let t = getftype t1 in
    S_RECORDREF(_1,_3), t
  )
# 1994 "kind1/lustre_parser.ml"
               : 'expr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 3 : string) in
    let _3 = (Parsing.peek_val __caml_parser_env 1 : 'expr) in
    Obj.repr(
# 861 "kind1/lustre_parser.mly"
  ( 
    (* placeholder *)
    _3 
  )
# 2005 "kind1/lustre_parser.ml"
               : 'expr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 3 : string) in
    let _3 = (Parsing.peek_val __caml_parser_env 1 : 'expr) in
    Obj.repr(
# 866 "kind1/lustre_parser.mly"
  ( 
    (* placeholder *)
    _3 
  )
# 2016 "kind1/lustre_parser.ml"
               : 'expr))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'exprlist) in
    Obj.repr(
# 871 "kind1/lustre_parser.mly"
  ( 
    let elist = List.rev _2 in
    let tlist = List.map (fun (_,x) -> x) elist in
    S_TUPLELIT(elist),L_TUPLE(tlist)
  )
# 2027 "kind1/lustre_parser.ml"
               : 'expr))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'exprlist) in
    Obj.repr(
# 877 "kind1/lustre_parser.mly"
  ( 
    let elist = List.rev _2 in
    let tlist = List.map (fun (_,x) -> x) elist in
    S_TUPLELIT(elist),L_TUPLE(tlist)
  )
# 2038 "kind1/lustre_parser.ml"
               : 'expr))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'expr) in
    Obj.repr(
# 883 "kind1/lustre_parser.mly"
  ( _2 )
# 2045 "kind1/lustre_parser.ml"
               : 'expr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'exprlist) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'expr) in
    Obj.repr(
# 887 "kind1/lustre_parser.mly"
  ( 
    (* returns a revered list! *)
    _3::_1 
  )
# 2056 "kind1/lustre_parser.ml"
               : 'exprlist))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'expr) in
    Obj.repr(
# 892 "kind1/lustre_parser.mly"
  ( [_1] )
# 2063 "kind1/lustre_parser.ml"
               : 'exprlist))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'syms) in
    Obj.repr(
# 896 "kind1/lustre_parser.mly"
  ( _1 )
# 2070 "kind1/lustre_parser.ml"
               : 'symlist))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'syms) in
    Obj.repr(
# 898 "kind1/lustre_parser.mly"
  ( _2 )
# 2077 "kind1/lustre_parser.ml"
               : 'symlist))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'sym_name) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'syms) in
    Obj.repr(
# 902 "kind1/lustre_parser.mly"
  ( _1::_3 )
# 2085 "kind1/lustre_parser.ml"
               : 'syms))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'sym_name) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'sym_name) in
    Obj.repr(
# 904 "kind1/lustre_parser.mly"
  ( [_1;_3] )
# 2093 "kind1/lustre_parser.ml"
               : 'syms))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : string) in
    Obj.repr(
# 908 "kind1/lustre_parser.mly"
      ( 
    if (String.length _1) > Globals.max_num_digits
    then 
      failwith ("Number " ^ _1 ^ " out of range.")
    else 
      int_of_string _1 
  )
# 2106 "kind1/lustre_parser.ml"
               : 'integer))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'integer) in
    Obj.repr(
# 917 "kind1/lustre_parser.mly"
          ( _1 )
# 2113 "kind1/lustre_parser.ml"
               : 'signed_integer))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'integer) in
    Obj.repr(
# 918 "kind1/lustre_parser.mly"
                ( - _2 )
# 2120 "kind1/lustre_parser.ml"
               : 'signed_integer))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : string) in
    Obj.repr(
# 922 "kind1/lustre_parser.mly"
  ( 
    if (String.contains _1 'E')  
    then (
      let rec n_0 n =
	if n = 1 then "0"
	else ("0" ^ (n_0 (n-1))) 
      in
      let last_ch str = 
	let len = String.length str in
	  if len > 0 
	  then String.get str (len - 1 ) 
	  else failwith "last_ch" 
      in 
      let rec cut_0 str =
	if String.length str <= 1 
	then str (*keep the last 0 *) 
	else if '0' = last_ch str 
	then cut_0 (String.sub str 0 ((String.length str) - 1))
	else str 
      in (*
      print_string $1 ; 
      print_string "\n";*)
      let e_pos = String.index _1 'E' in
      let dot_pos = String.index _1 '.' in
	assert (dot_pos = 1);
	assert (e_pos + 4 = String.length _1);
      let e_sign =  String.get  _1 (e_pos+1) in
	assert ('-' = e_sign || '+' = e_sign );
      let e_str = String.sub _1 (e_pos+2) 2 in 
      let shift_value =  
	let v = (int_of_string e_str) in
	  if '-' = e_sign then -v
	  else v 
      in
      let v1_str = String.sub _1 0 1 in
      let v2_str = String.sub _1 (dot_pos + 1 ) (e_pos - dot_pos - 1) in
      let v_str = v1_str ^ v2_str in
      let cut_pos, value = 
	if (shift_value < 0) then 1, (cut_0 ((n_0 (abs shift_value)) ^ v_str ))
	else if (shift_value + 2) > String.length v_str
	then (shift_value + 1), (v_str ^ (n_0 (shift_value + 1 + 1 - (String.length v_str)))) 
	else (shift_value + 1), v_str 
      in
      let n = int_of_string (String.sub value 0 cut_pos) in
      let p_len = (String.length value) - cut_pos in
      let d_str = cut_0 (String.sub value cut_pos p_len) in
      let d = int_of_string d_str in
      let p = int_of_string ("1" ^ (n_0 (String.length d_str))) in
	(n,d,p)
    )
    else 
      let pos = String.index _1 '.' in
      if pos > Globals.max_num_digits then
	failwith  ("Number " ^ _1 ^ "out of range.") ;
      let len = 
	let act_len = (String.length _1)-pos-1 in
	  if act_len <= Globals.max_num_digits 
	  then act_len
	  else 
	    let warn_msg = "Warning: " ^ _1 ^ " too long, truncated into " ^
	      (String.sub _1 0 (pos + Globals.max_num_digits + 1)) in
	      print_string warn_msg;
	      print_newline();
	      Globals.max_num_digits 
      in
      let n = String.sub _1 0 (pos) in
      let d = String.sub _1 (pos+1) len in
	(* Yeting. 1.03 --> 1, 03, 100 --> 1 + (03/100) *)
	(int_of_string(n),int_of_string(d),int_of_float(10.0**float_of_int(len))) 
  )
# 2196 "kind1/lustre_parser.ml"
               : 'real))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : string) in
    Obj.repr(
# 994 "kind1/lustre_parser.mly"
      ( Tables.rename_sym _1 )
# 2203 "kind1/lustre_parser.ml"
               : 'sym_name))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'record_literal_field) in
    Obj.repr(
# 998 "kind1/lustre_parser.mly"
  ( [_1] )
# 2210 "kind1/lustre_parser.ml"
               : 'record_literal_fields))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'record_literal_fields) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'record_literal_field) in
    Obj.repr(
# 1000 "kind1/lustre_parser.mly"
  ( _3::_1 )
# 2218 "kind1/lustre_parser.ml"
               : 'record_literal_fields))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'sym_name) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'expr) in
    Obj.repr(
# 1005 "kind1/lustre_parser.mly"
  ( (_1,_3) )
# 2226 "kind1/lustre_parser.ml"
               : 'record_literal_field))
(* Entry main *)
; (fun __caml_parser_env -> raise (Parsing.YYexit (Parsing.peek_val __caml_parser_env 0)))
|]
let yytables =
  { Parsing.actions=yyact;
    Parsing.transl_const=yytransl_const;
    Parsing.transl_block=yytransl_block;
    Parsing.lhs=yylhs;
    Parsing.len=yylen;
    Parsing.defred=yydefred;
    Parsing.dgoto=yydgoto;
    Parsing.sindex=yysindex;
    Parsing.rindex=yyrindex;
    Parsing.gindex=yygindex;
    Parsing.tablesize=yytablesize;
    Parsing.table=yytable;
    Parsing.check=yycheck;
    Parsing.error_function=parse_error;
    Parsing.names_const=yynames_const;
    Parsing.names_block=yynames_block }
let main (lexfun : Lexing.lexbuf -> token) (lexbuf : Lexing.lexbuf) =
   (Parsing.yyparse yytables 1 lexfun lexbuf : Types.il_formula * Types.typed_stream * Types.typed_stream list * Types.node_id_t)
